/**
 * MCP Server configuration for Discogs
 * Uses the official @modelcontextprotocol/sdk with Cloudflare Agents SDK
 */
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import type { Env } from "../types/env.js";
import { registerPublicTools } from "./tools/public.js";
import { registerAuthenticatedTools } from "./tools/authenticated.js";
import { registerResources } from "./resources/discogs.js";
import { registerPrompts } from "./prompts/collection.js";
import { verifySessionToken, type SessionPayload } from "../auth/jwt.js";

/**
 * Session context - extracted from request for tool access
 */
export interface SessionContext {
	session: SessionPayload | null;
	connectionId?: string;
}

/**
 * Extract session from request (cookies or connection-specific storage)
 * The sessionId is passed explicitly (generated by the caller if not provided in request)
 */
async function extractSessionFromRequest(
	request: Request,
	env: Env,
	sessionId: string
): Promise<SessionContext> {
	// Debug: Log session ID
	console.log("Session ID extraction:", {
		providedSessionId: sessionId,
	});

	// Try to get session from cookie
	try {
		const cookieHeader = request.headers.get("Cookie");
		if (cookieHeader) {
			const cookies = cookieHeader.split(";").reduce(
				(acc, cookie) => {
					const [key, value] = cookie.trim().split("=");
					if (key && value) {
						acc[key] = value;
					}
					return acc;
				},
				{} as Record<string, string>
			);

			const sessionToken = cookies.session;
			if (sessionToken) {
				const session = await verifySessionToken(sessionToken, env.JWT_SECRET);
				if (session) {
					return { session, connectionId: sessionId };
				}
			}
		}
	} catch (error) {
		console.error("Error verifying cookie session:", error);
	}

	// Try connection-specific authentication if we have KV storage
	if (sessionId && env.MCP_SESSIONS) {
		try {
			const kvKey = `session:${sessionId}`;
			console.log(`Looking up KV key: ${kvKey}`);
			const sessionDataStr = await env.MCP_SESSIONS.get(kvKey);
			if (sessionDataStr) {
				const sessionData = JSON.parse(sessionDataStr);
				console.log(`Found session for user: ${sessionData.userId}`);

				// Verify the stored session is still valid
				if (
					!sessionData.expiresAt ||
					new Date(sessionData.expiresAt) <= new Date()
				) {
					console.log("Connection session has expired");
					return { session: null, connectionId: sessionId };
				}

				// Return session payload
				const session: SessionPayload = {
					userId: sessionData.userId,
					accessToken: sessionData.accessToken,
					accessTokenSecret: sessionData.accessTokenSecret,
					iat: Math.floor(Date.now() / 1000),
					exp: Math.floor(new Date(sessionData.expiresAt).getTime() / 1000),
				};

				return { session, connectionId: sessionId };
			} else {
				console.log(`No session found for key: ${kvKey}`);
			}
		} catch (error) {
			console.error("Error retrieving connection session:", error);
		}
	}

	return { session: null, connectionId: sessionId };
}

/**
 * Creates and configures the MCP server with all tools, resources, and prompts
 * Uses factory pattern to provide env and request context access via closures
 * @param env - Cloudflare Worker environment bindings
 * @param request - The incoming HTTP request
 * @param sessionId - Session ID (generated by caller if not provided in request headers)
 */
export function createServer(env: Env, request: Request, sessionId: string): McpServer {
	const server = new McpServer({
		name: "discogs-mcp",
		version: "1.0.0",
	});

	// Create a session context holder that will be populated lazily
	let sessionContextCache: SessionContext | null = null;
	let sessionContextPromise: Promise<SessionContext> | null = null;

	// Lazy session extraction - only extract session when first tool is called
	const getSessionContext = async (): Promise<SessionContext> => {
		// If we've already extracted session, return it immediately
		if (sessionContextCache) {
			return sessionContextCache;
		}

		// If extraction is in progress, await it
		if (sessionContextPromise) {
			return await sessionContextPromise;
		}

		// Start extraction
		sessionContextPromise = extractSessionFromRequest(request, env, sessionId).then(
			(context) => {
				sessionContextCache = context;
				return context;
			}
		);

		return await sessionContextPromise;
	};

	// Register public tools (available without authentication)
	// Pass session context so they can include connection ID in auth URLs
	registerPublicTools(server, env, getSessionContext);

	// Register authenticated tools with session context provider
	registerAuthenticatedTools(server, env, getSessionContext);

	// Register resources (require authentication)
	registerResources(server, env, getSessionContext);

	// Register prompts (common workflows)
	registerPrompts(server);

	return server;
}
